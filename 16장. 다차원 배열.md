### ㅘ16장. 다차원 배열

가로 행 세로 열



#### 16-1. 다차원 배열

* 다차원 배열이란?

> 2차원 이상의 배열

```c
/*다차원 배열 예시*/
* int arr[100] : 1차원 배열
* int arr[10][10] : 10*10, 2차원 배열
* int arr[5][5][5] : 5*5*5 3차원 배열
```

* 1차원 배열과 다차원 배열의 차이점?

> * n개의 원소를 가지는 1차원 배열 : 길이가 n인 1차원 배열
>
> * n*m개의 원소를 가지는 2차원 배열 : 
>
> n : 세로줄(열의 길이)
>
> m : 가로줄(행의 길이) 

* 2차원 배열의 표현 방법

```C
(예시 : int arr[2][7])
1. 길이가 7인 int형 배열을 두 개 모아놓은 배열의 선언
2. 세로의 길이가 2이고 가로의 길이가 7인 배열의 선언
```

* 2차원 배열의 index는 1차원 배열과 마찬가지로 (0,0)부터 시작한다.



* 2차원 배열! 선언과 동시에 초기화

* (책의.. 예시들....)

  * 1. 행 단위로 모든 요소들을 초기화

    2. 행 단위로 일부 요소들만 초기화

    3. 1차원 배열 초기화 형태를 취한다.

       > 초기화 리스트의 수가 배열 요소의 수보다 적은 경우에는 나머지 요소들을 0으로 초기화

* 배열의 크기를 알려주지 않고 초기화하기

  * 2차원 배열에서 선언과 동시에 값을 대입하여 초기화 하는 경우, 세로줄(열)의 값만 생략이 가능하다.

  * ```c
    /*열의 값을 생략하고 선언하는 2차원 배열의 예시*/
    int arr[][4] = {1,2,3,4,5,6,7,8}
    ```



#### 16-2. 3차원, 그 이상의 배열

(이미지 넣기)



### 17장. 포인터의 포인터



#### 17-1. 포인터의 포인터에 대한 이해

* 포인터의 포인터(pointer to pointer) = 더블 포인터(double pointer)

  ```c
  /*더블 포인터의 선언 예시*/
  int **dp
  /*포인터 선언에 사용되는 '*'기호를 두 번 써준다.*/
  ```

  

* 더블 포인터가 가리키는 것은? => 싱글 포인터
* 변수와 포인터 : 둘 다 변수이며, 메모리 공간을 할당받고 데이터를 저장
  * 포인터가 또 다른 포인터에 의해 주소값이 저장되어 있을 수 있는 이유.
  * 더블 포인터 : 싱글 포인터의 주소 값을 저장하기 위한 용도로 사용되는 포인터



* [ 변수 ] 
*  [ 포인터(변수의 주소값) ] 
*  [더블 포인터(변수의 주소값을 가리키는 포인터의 주소값)]



* 더블 포인터에 의한 Call-by-Reference
* 포인터를 함수의 매개변수로 넘겨준다면?

```c
/*매개변수가 포인터인 함수를 이용하여 각 포인터의 값을 변경하려는 경우, 변수를 Call-by-Value 값으로 넘겨주는 것과 같다는 것을 보여주기 위한 코드입니다.*/
#include<stdio.h>

void pointer_swap(int *pointer1, int *pointer2);

int main(void)
{
    /*변수 및 포인터 선언 및 초기화*/
    int value1 = 0;
    int value2 = 0;
    value1 = 10;
    value2 = 20;
    
    int *pval1 = NULL;
    int *pval2 = NULL:
    pval1 = &value1;
    pval2 = &value2;
    
    /*pointerswap 함수의 호출 전*/
    printf("pval1이 가리키는 변수 : %p\n", *pval1);
    printf("pval2이 가리키는 변수 : %p\n", *pval2);
    
    pointerswap(pval1, pval2);
    
    /*pointerswap 함수의 호출 후*/
    printf("pval1이 가리키는 변수 : %p\n", *pval1);
    printf("pval2이 가리키는 변수 : %p\n", *pval2);
    
    return 0;
}

/*각 포인터가 가리키는 변수를 swap해주기 위한 함수*/
void pointer_swap(int *pointer1, int *pointer2)
{
    int *p_temp = NULL;
    
    /*포인터를 매개변수로 함수에서 변수로 사용하면 
    printf 사용 시 %p로 받고, 
    전달 인자는 * 없이 쓰는 것인지.. 궁금*/
    if(pointer1 == NULL || pointer2 == NULL){
        printf("포인터가 NULL입니다.\n pointer1(%p), pointer2(%p)", pointer1, pointer2);
    }
    
    p_temp = pointer1;
    pointer1 = pointer2;
    pointer2 = p_temp;

return;    
}

```

> 포인터의 주소값을 복사하여 전달받으므로, 
>
> 포인터가 가리키는 변수에 대해 직접적인 변경은 가능하지만,
>
> 포인터 자체는 복사값이므로 변경해도 아무 소용이 없다.
>
> 포인터를 바꿔주고 싶다면 포인터를 가리키는 포인터의 주소값을 전달받아 바꾸는 것이 맞음.



```c
/**포인터 값을 변경해줄 수 있도록 더블 포인터를 매개변수로 받도록 변경한 pointer_swap*/
void pointer_swap(int **pointerl, int **pointer2)
{
    /*
    **pointer1이 가리키는 것 : *pointer1의 주소값
    **pointer2가 가리키는 것 : *pointer2의 주소값
    */
    
	int *p_temp = NULL;
    
    if(pointer1 == NULL || pointer2 == NULL){
        printf("더블 포인터가 NULL입니다.\n pointer1(%p), pointer2(%p)", pointer1, pointer2);
    }
    
	p_temp = *pointer1;
    
	*pointer1 = *pointer2;
	*pointer2 = p_temp;
return;
} 
```



* 포인터 배열과 포인터 타입
  * 배열 이름의 포인터 타입을 결정짓는 요소 : 배열의 첫번째 요소!!



### 18장. 다차원 배열 그리고 포인터



#### 18-1. 2차원 배열 이름의 포인터 타입

* 2차원 배열의 이름이 가리키는 것 : 

* 그림()

* 2차원 배열 포인터 선언 

* 자료형 (*배열의 이름) [배열의 가로 크기];

*  자료형 배열의 이름`[][배열의 가로 크기]`

  * > 함수의 매개 변수 선언 시에만 가능한 배열의 포인터 선언
    >
    > 매개 변수의 자리 외에 선언하게 되면 열의 크기를 생략한 배열 선언으로 인식됨

* 괄호의 중요성..

  >  int * arr[4]; // 포인터 배열 : int형 포인터 변수로 이루어진 int형 포인터 배열

  > int (*arr) [4]; // 배열 포인터 : 열이 4개인 int형 2차원 배열을 가리키는 포인터 변수



* 2차원 배열의 이름 + 1 : 배열의 이름을 이용한 포인터 연산
  * 2차원 배열 이름은 포인터 연산시 *행 단위* 로 이동

  * ```C
    /*2차원 배열의 포인터 연산 예시*/
    int array[3][2];
    => 가로로 2행, 세로로 3열의 2차원 배열
    /*0으로 초기화 한다면 출력 예시*/
        0  0
        0  0
        0  0
    /*배열의 이름은 곧 배열의 포인터! 배열의 이름으로 연산을 실행할 시*/   
    printf("array + 0 연산 값 : %p",array);
    printf("array + 1 연산 값 : %p",array+1);
    printf("array + 2 연산 값 : %p",array+2);
    /*출력 결과 , int = 4 바이트 */
    array + 0 연산 값: 1245032
    array + 1 연산 값: 1245040
    array + 2 연산 값: 1245048 
    /*주소 값이 8씩 차이가 남. 각각의 포인터 연산을 통한 주소가 가리키고 있는 배열의 요소들*/
    array + 0 : array[0][0]~array[0][1]
    array + 1 : array[1][0]~array[1][1]
    array + 2 : array[2][0]~array[2][1]
    ```



* 포인터 타입에는 이동에 대한 정보가 들어있다!?
  * 포인터 연산 시 증가되는 값으로 포인터가 몇 개의 배열요소를 건너뛰는지 알 수 있음



#### 18-2. 2차원배열에서의 “arr[i]" 와 “* (arr+ i)"은 같다.



### 19장. 함수 포인터와 void 포인터



#### 19-1. 함수 포인터

* 함수 포인터란?

>  메인 메모리에 올라와 있는 함수를 가리킬 수 있는 포인터

>  함수의 이름 : 

>  메모리상에 존재하는 함수의 위치를 가리키는 포인터

> (상수) 포인터



* 함수 이름의 포인터 타입을 결정짓는 요소

> 반환값과 전달인자.



* 함수 포인터의 선언

그림()



#### 19-2. void형 포인터



* void 포인터는 뭐든 담을 수 있는 바구니?
  * void 포인터 변수에는 변수, 함수, 포인터 등등의 *주소값*을 저장할 수 있다.
  * 그러나 주소값의 자료형을 알지 못하기 때문에 주소값의 단순 저장밖에는 할 수 없다.
  * void형 포인터 변수에 *명시적 형변환* 을 거친 뒤에 주소값에 해당하는 값에 직접 접근할 수 있다.
  * 메모리의 동적 할당에서 유용하게 쓰인다.



#### 19-3. main함수도 인자를 받을 줄 알아요.



