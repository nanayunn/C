h2. < 14장. 포인터와 함수에 대한 이해>



h3. 함수의 인자로 배열 전달하기



* 함수의 인자 전달 방식

* 인자 전달의 기본 방식 : 복사

  * 전달되는 값 : 매개 변수라는 것을 통해서 전달

  * ```c
    /* 함수의 인자 전달 방식을 설명하기 위한 코드입니다. */
    #include<stdio.h>
    
    /*매개 변수에 1을 더하여 반환하는 int형 함수*/
    int plus_val(int value)
    {
        value++;
        return value;
        
    }
    
    int main(void)
    {
        int val = 0;
        val = 10;
        
        /* 매개 변수에 1을 더하여 반환하는 함수
        val의 값은 매개변수 value의 값으로 전달된다.*/
        plus_val(val);
        
        return 0;
    }
    ```

* 배열을 함수의 인자로 전달하는 방식

  * 배열을 매개 변수 설정 시, 단일 자료형과 다르게

  * ```c
    /*매개 변수를 배열로 받아 배열의 첫번째 index 위치에 있는 값을 출력하는 함수입니다.*/
    #include<stdio.h>
    
    void print_array(int *array)
    {
        printf("함수 대입(기존의) array[0] : %d \n", array[0]);
        
        array[0] = 3;
        
        return 0;
    }
    
    int main(void)
    {
        int arr[2] = {};
        arr[2] = { 1, 2 };
        
        print_array(arr);
        
        print("함수 대입 후 array[0] : %d \n", arr[0]);
        
        return 0;
    }
    ```

  * 이와 같이 *(포인터)를 변수 앞에 붙여, 

  * 배열의 값을 전달 하는 것이 아니라 배열의 주소를 전달하는 방식으로 매개 변수를 설정하게 된다.

  * 배열의 이름 : 첫 번째 요소의 주소 값을 의미하는 상수 포인터

  * 즉, 배열 arr과 매개 변수 array는 같은 배열을 가리키는 포인터가 되는 것.

  * 이러한 경우, 위의 단일 변수가 매개 변수가 된 경우 처럼 복사본을 넘겨주는 것이 아니라, 같은 포인터로써 같은 값을 가르키고 있기 때문에 값의 변경이 반영이 된다.

* 배열의 길이를 구하는 방법?
  * sizeof연산자 활용!
  * sizeof(배열) = 배열의 전체 크기(바이트 단위)
  * sizeof(배열의 자료형 or 포인터 배열) = 배열 한 칸이 쓰고 있는 메모리의 크기/ 즉, 포인터 변수의 크기(첫 번째 배열의 크기)
  * 따라서 sizeof(배열)/sizeof(배열의 자료형) 를 하게 되면
    * 배열의 길이를 구할 수 있다.



h3. Call-by-Value와 Call-by-Reference



* Call-by-Value(값에 의한 호출)

  * 기본 호출 방식 : 값의 복사

  * ```
    /*swap이라는 매개 변수 두 개의 값을 서로 바꿔주는 함수를 작성하고, 
    이 함수가 작동하였을 때 매개 변수로 지정된 각 변수의 값이 main 함수 내에서 변경되는 지 확인하기 위한 코드 입니다.*/
    #include<stdio.h>
    
    int swap(int value1, int value2)
    {
    	/*temp 변수 초기화
    	전달받은 매개 변수 중 하나의 값을 저장해 놓기 위한 용도*/
    	int temp = 0;
    	
    	/*순환 구조 형식으로 temp에는 value1의 값을,
    	value1에는 value2의 값을,
    	value2에는 temp(value1)의 값을 넣어준다.*/
    	
    	temp = value1;
    	value1 = value2;
    	value2 = temp;
    	
    	return 0;
    }
    
    int main(void
    {
    	int val1 = 0;
    	int val2 = 0;
    	val1 = 10;
    	val2 = 20;
    	
    	swap(val1, val2);
    	
    	return 0;
    }
    ```

  * swap함수 속 value1과 value2는val1과 val2의 복사본이며, 

  * Call-by-Value 의 방식으로 넘겨준 변수는 복사본일뿐 동일한 변수를 가리키지 않는다.



* Call-by-Reference(참조에 의한 호출)
  * Call-by-value와 달리 복사본 X
  * 원본의 주소를 넘겨주어 동일한 변수를 다룰 수 있도록 하는 것!
  * => 인자로 전달된 주소가 가리키는 변수의 조작을 함수 내에서 가능하게 하는 것.



* scanf 함수 호출 시 '&'를 붙이는 이유?
  * 변수에 접근하여 값을 대입할 필요가 있음 => 변수의 주소 필요
  * 문자열은 왜 &를 붙이지 않는가?
    * 문자열 : 배열
    * 문자열의 이름 : 배열의 이름 => 즉, 배열의 주소 포인터 그 자체!



h3. 포인터와 const 키워드



* const 키워드?

  > 상수를 만들 때 사용!
  >
  > 포인터 선언 시 사용 : 포인터를 상수화
  >
  > 1. 포인터 자체를 상수화 한다.
  > 2. 포인터가 가리키는 변수를 상수화한다.
  > 3. **const 위치에 주의해야함**

* 1. 포인터가 가리키는 변수의 상수화

* ```c
  /*const 키워드를 사용하여 변수 value의 값을 상수화 하는 코드 예시 부분*/
  int value = 10;
  const int* pointer = &value;
  /*위와 같은 변수와 포인터를 예시로 들어 설명하고자 하였을 때, */
  
  *pointer = 30; /*포인터를 이용한 변수 값 변경 불가*/
  value = 30; /*변수 자체의 값 변경은 가능!*/
  ```

* 포인터가 가리키는 변수가 상수화(X)

* 포인터를 이용해 포인터가 가리키는 변수의 값을 변경하는 것을 막는 것(O)

* 2. 포인터 상수화

* ```c
  /*const 키워드를 사용하여 포인터를 상수화 하는 코드 예시 부분*/
  int value = 1;
  int value2 = 2;
  int* const pointer = &value;
  /*위와 같은 변수와 포인터를 예시로 들어 설명하고자 하였을 때, */
  
  *pointer = 30; /*포인터를 이용해 할당된 변수 값 변경 가능*/
  
  pointer = &value2; /*포인터에 다른 변수에 대한 주소 할당이 불가능!*/
  ```

* 포인터가 지니는 주소값의 변경이 불가능해진다.

* 포인터&포인터가 가리키는 데이터 상수화를 동시에 진행하려면?!

* ```c
  /*위의 조건을 만족시키기 위해 const 키워드의 사용방법을 명시하는 코드 예시 부분*/
  int value = 10;
  const int* const pointer = &value;
  ```

* `const` 키워드의 사용은 협업 프로그래밍 시 의도치 않은 값의 변경을 막아주는 역할을 한다.